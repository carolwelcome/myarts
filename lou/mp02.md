---
title: 02.并发编程之源头问题解决思路
date: 2019-07-02 18:38:22
categories:  #分类
    - 并发编程
tags:   #标签
    - Java
    - multi
description: 
    理论基础
---

#### 对症下药
既然知道了问题的源头在哪儿（可见性问题、原子性问题、有序性问题），那该如何解决问题呢？而且这些问题还都是通用性的问题，不像在搬砖填坑的时候似的，哪儿有问题补哪儿，这个问题得从更底层来解决，当然能从硬件来把这些问题是最好的，不仅性能好，而且还操作还简单，但这是只是yy。好吧，既然这条路走不通，那就再换一条，从操作系统上怎么样？当然也是可以的，但各大编程语言并不看好这种形式，因为如果从操作系统层面上解决了，那只需要控制操作系统就行了，还有这些编程语言什么事呢？因此各大主流编程语言纷纷努力，争取以最快的速度来解决这些问题，而其中的代表就是Java语言所推出的Java内存模型。当然解决问题思路也还是针对问题来解决，头疼医头，脚疼刖之。可见性问题是吧？我只需要提“按需使用缓存”就ok了，有序性问题，我告诉你JVM虚拟机什么时候需要优化，什么时候不优化，是不是也可以！原子性问题？不就是线程切换产生吗，我把你线程切换给禁用掉怎么样，让CPU禁发生中断，我看你还怎么切，切你妹呀切。当然这是一些粗俗的表达，如果用技术手段来实现，这就可以称为是优雅了。

#### Java内存模型
从程序员的角度上来，Java内存模型规范了JVM如何提供这种按需提供缓存、编译优化以及锁的方法。对应到实现上就是volitale、synchronized、final三个关键字，以及6项happens-before规则。

1、程序顺序性规则 
2、volatile变量规则（从内存中读取、禁止优化）
3、传递性
4、管程中的锁
5、线程start()
6、线程join()


final表示，编译器可以优化
#### 原子性问题
锁
synchronized (修饰类、修饰方法、修饰变量)
锁与资源的关联（N:1)、细粒度锁、更大粒度的锁
