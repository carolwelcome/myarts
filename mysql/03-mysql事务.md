---
title: 03.MySQL:事务隔离
date: 2019-06-12 13:45:22
categories:  #分类
    - attendance
tags:   #标签
    - MySQL
    - 架构 
description: 
    MySQL基础知识学习
---
### 事务性
1、事务就是保证一组数据库操作，要么全部成功，要么全部失败。
2、事务在引擎层实现，不是所有的引擎都支持事务比如MyISAM就不支持事务，这也是被InnoDB取代的原因
3、
### 隔离级别
1、事务特性：ACID,原子性、一致性、隔离性、持久性
2、隔离级别解决：脏读、不可重复读、幻读问题
3、隔离级别越高，数据库的效率就越低，需要有场景的选择
4、隔离级别：
	a.读未提交（read uncommitted)
	b.读已提交（read committed）
	c.可重复读（repeatable read）
	d.串行化（serializable）
#### 读未提交
一个事务在没有提交的时，它的变更可以被其他事务看到。
存在的问题：脏读。即读取到不正确的数据，因为另一个事务可能还没提交最终数据，这个读事务就读取了中途的数据，这个数据可能是不正确的。
解决办法就是下面的“可读取确认”。
#### 读已提交
一个事务在提交之后 ，它的变更才可以被其他事务看到。
Sql Server , Oracle的默认隔离级别
写事务会阻止其他读写事务。读事务不会阻止其他任何事务。
存在的问题：不可重复读。即在一次事务之间，进行了两次读取，但是结果不一样，可能第一次id为1的人叫“李三”，第二次读id为1的人就叫了“李四”。因为读取操作不会阻止其他事务。

解决办法就是下面的“可重复读”。
#### 可重复读
一个事务在执行过程中看到数据，总是跟这个事务在启动时看到的数据是一致的，在该模式下，未提交的变更对其他事务不可见
MySQL的默认隔离级别

读事务会阻止其他写事务，但是不会阻止其他读事务。

存在的问题：幻读。可重复读阻止的写事务包括update和delete（只给存在的表加上了锁），但是不包括insert（新行不存在，所以没有办法加锁），所以一个事务第一次读取可能读取到了10条记录，但是第二次可能读取到11条，这就是幻读。

解决办法就是下面的“串行化”。
#### 串行化
对于同一个事务，“写”会加写锁，“读”会加读锁，当出现读写锁冲突的时候，后访问的事务必须等待前一个事务执行完成，才能继续执行。

可避免幻读。读加共享锁，写加排他锁。这样读取事务可以并发，但是读写，写写事务之间都是互斥的，基本上就是一个个执行事务，所以叫序列化。
### 隔离实现
在实现上，数据库会创建一个视图，访问的时候以视图的逻辑结果为准。在可重复读隔离级别下，这个视图是在事务启动的时候创建的，整个事务在期间都使用这个视图，在读已提交隔离级别下，这个视图是在每个SQL语句执行的时候创建的。读未提交隔离级别下，直接返回记录上的最新值，没有视图的概念，串行化隔离级别下，直接用加锁的方式来避免，并行访问。
Oracle的默认隔离级别是`读已提交`,在做异构数据迁移时需要注意对不同隔离级别的设置。

长事务风险：长事务意味着系统里面会存在很老的事务视图，由于这些事务随时可以访问数据库里面的任何数据，所在这个事务提交之前数据库里面它可用的回滚记录都必须保留，会导致占用很大的存储空间。此外，长事务还占用锁资源，也可能拖垮整个库。

### 配置方式
将启动参数，transaction-isolation值，设置成READ-COMMITTED。你可以用show variables来查看当前值。
```
mysql> show variables like 'transaction_isolation';

+-----------------------+----------------+

| Variable_name | Value |

+-----------------------+----------------+

| transaction_isolation | READ-COMMITTED |

+-----------------------+----------------+

```

### 事务启动方式
1、显式启动事务，begin或start transaction,配套的提交语句是commit,回滚语句是rollback。
2、set autocommit=0,这个命令会将这个线程的自动提交关掉，意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交，这个事务会持续存在直到你主动执行commit或者rollback语句或者断开连接

可以在 information_schema 库的 innodb_trx这个表中查询长事务，
```
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60

```


### 脏读是怎么产生的，如何解决
简单一句话，读到脏数据了。那什么脏数据呢？脏数据就是错误的数据，比如账户余额是200，第一个事务进来给余额加100，没有加完，另一个事务又进来给余额减了50，并提前提交了事务，之后第一个事务才完成提交。这时候余额应该是多少呢？如果没有对事务进行处理的话最终的结果会是300，但此时正确的结果应该是250。我的这种描述是对的吗？答案是不对的，正确的描述应该是这样：脏数据首先不是错误的数据，而是事务过程中的数据，还拿账户余额的这个例子，账户余额是200，第一个事务进来给余额加了100，此时事务的隔离级别是读未提交，另一个事务进来之后，读取到余额为300，并基于此对余额减了50。此时如果第一个事务如果进行回滚话，后面这个事务也就不可能是正确的了，这也就是脏读。
这种情况该怎么解决呢？前文也提到，这种情况主要是发生在读未提交这种隔离级别之下，如果把事务隔离级别调成读已提交这种情况也解决了。与此同时，在读未提交的级别之下，不可重复读、幻读这种情况也都是可能发生的。

### 不可重复读是怎么产生的，如何解决
不可重复读也叫虚读，是说在一个事务A中多次操作一个数据，在这两次或多次访问这个数据的中间，事务B也操作此数据，并使其值发生了改变，这就导致同一个事务A在两次操作这个数据的时候值不一样，这就是不可重复读。
可重复读隔离级别
### 幻读是怎么产生的，如何解决
直白一点：一个事务第一次读取可能读取到了10条记录，但是第二次可能读取到11条，这就是幻读。
是指事务不独立执行产生的一种现象。事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。这样就会导致当A本来执行的结果包含B执行的结果，这两个本来是不相关的，对于A来说就相当于产生了“幻觉”。
串行化隔离级别