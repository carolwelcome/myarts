---
title: 03.MySQL:事务隔离
date: 2019-06-12 13:45:22
categories:  #分类
    - attendance
tags:   #标签
    - MySQL
    - 架构 
description: 
    MySQL基础知识学习
---
### 事务性
1、事务就是保证一组数据库操作，要么全部成功，要么全部失败。
2、事务在引擎层实现，不是所有的引擎都支持事务比如MyISAM就不支持事务，这也是被InnoDB取代的原因
3、
### 隔离级别
1、事务特性：ACID,原子性、一致性、隔离性、持久性
2、隔离级别解决：脏读、不可重复读、幻读问题
3、隔离级别越高，数据库的效率就越低，需要有场景的选择
4、隔离级别：
	a.读未提交（read uncommitted)
	b.读已提交（read committed）
	c.可重复读（repeatable read）
	d.串行化（serializable）
#### 读未提交
一个事务在没有提交的时，它的变更可以被其他事务看到。
#### 读已提交
一个事务在提交之后 ，它的变更才可以被其他事务看到。

#### 可重复读
一个事务在执行过程中看到数据，总是跟这个事务在启动时看到的数据是一致的，在该模式下，未提交的变更对其他事务不可见

#### 串行化
对于同一个事务，“写”会加写锁，“读”会加读锁，当出现读写锁冲突的时候，后访问的事务必须等待前一个事务执行完成，才能继续执行。
### 隔离实现
在实现上，数据库会创建一个视图，访问的时候以视图的逻辑结果为准。在可重复读隔离级别下，这个视图是在事务启动的时候创建的，整个事务在期间都使用这个视图，在读已提交隔离级别下，这个视图是在每个SQL语句执行的时候创建的。读未提交隔离级别下，直接返回记录上的最新值，没有视图的概念，串行化隔离级别下，直接用加锁的方式来避免，并行访问。
Oracle的默认隔离级别是`读已提交`,在做异构数据迁移时需要注意对不同隔离级别的设置。

长事务风险：长事务意味着系统里面会存在很老的事务视图，由于这些事务随时可以访问数据库里面的任何数据，所在这个事务提交之前数据库里面它可用的回滚记录都必须保留，会导致占用很大的存储空间。此外，长事务还占用锁资源，也可能拖垮整个库。

### 配置方式
将启动参数，transaction-isolation值，设置成READ-COMMITTED。你可以用show variables来查看当前值。
```
mysql> show variables like 'transaction_isolation';

+-----------------------+----------------+

| Variable_name | Value |

+-----------------------+----------------+

| transaction_isolation | READ-COMMITTED |

+-----------------------+----------------+

```

### 事务启动方式
1、显式启动事务，begin或start transaction,配套的提交语句是commit,回滚语句是rollback。
2、set autocommit=0,这个命令会将这个线程的自动提交关掉，意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交，这个事务会持续存在直到你主动执行commit或者rollback语句或者断开连接

可以在 information_schema 库的 innodb_trx这个表中查询长事务，
```
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60

```