1、java编程思想（java核心），找自己薄弱的知识点来学习
2、企业应用架构模式(EA)
3、java并发编程实战

基础：线程安全基础知识，关键字使用场景，多线程之间的通信
中级：并发编程集合类，经典设计模式（future模式-netty、Master-Worker模式-流式计算),实际应用场景
高级：executors、多任务执行框架、工具类（concurrent.util)、锁高级深化、disruptor框架

课程：并发编程，MQ


并发编程02

线程安全：当多个线程访问某一个类（对象或方法）时，这个类始终都能表现出正确的行为，那么这个类就是线程安全的。
synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为互斥区或临界区。
多个线程多个锁：多个线程，每个线程都可以拿到自己指定的锁，分别获得锁之后执行synchronized方法体的内容。static automaticInteger（原子性操作）
synchronized取得的锁是对象锁，不是把一段代码当做锁，所以线程先执行synchronized关键字的方法，那个线程就持有该方法所属对象的锁，两个对象，线程获得的就是两个不同的锁，它们互不影响。在静态方法上加synchronized关键字，表示锁定.class类，类一级别的锁（独占锁）

同步/异步
synchronized(共享)/asynchronized(ajax)
同步的目的就是为了线程安全，线程安全需要满足两个特性：
原子性、可见性、有序性
脏读，数据一致性问题


volatile:使变量在多个线程间可见。它虽然拥有多个线程之间的可见性，但是却不具务同步性，可以算上是一个轻量级的synchronized,性能要比sync强，不会造成阻塞。netty中底层代码大量使用了volatile.
volatile只具有可见性，没有原子性，
static 并不能保证原子性。

多线程通信：wait notify(配合synchronized使用)，wait方法释放锁，notify不释放锁
CountDownLatch(可以解决通知即执行，区别锁，本身就相当于一个tag)

代码实现：
有两个线程，访问同一个变量，当变量满足第二个线程的条件时，中止第二个线程，中止第一个线程。请用代码实现

